---
title: "Generalized Test of MODMCMC"
author: "Michael Najarro"
date: "6/27/2021"
output: html_document
---

# Introduction

The underyling goal of this project is to evaluate whether the MEM-PEPRMT model can predict coastal wetland methane emissions on a national scale by implementing the model on wetland data from multiple sites.

However, to run this model, parameters involved in physical chemistry within PEPRMT must be parameterized.


# Goal
This script is a test run of implementing the package FME's function `modMCMC`, which implements a delayed rejection adaptive monte carlo markov chain algorithm, to estimate theta parameters for PEPRMT upon a multi site data set.

The data used for PEPRMT Ch4 comes from `test1_forDRAM.rds`. 



# The Process

```{r, echo=FALSE, message=FALSE}
library(pacman)
p_load(R.matlab,
       here,
       tidyverse,
       magrittr,
       FME,
       tictoc,
       beepr)
```

## 1. Build error data set

Estimating parameters for PEPRMT requires having eddy covariance data in order to calculate an error term (or vector of terms) for DRAM. The data is comprised of a data frame containing the methane, daily integral error (gap filled), and random error from Eddy Covariance Towers.

For MEM-PEPRMT, we will calculate a sum of squares on the error data, which will later applied to the DRAM parameter space selection distribution. 

Unfortunately error data exists only for Eden landing. To create error data for Rush Ranch and St. Jones, I will sample with replacement EL.

For each day that exists within a given data set, there should exist three error values: ydata, gpf, and re.

first identify the number of days of data per site, by recording the number of rows per site.

```{r}
# #load in the data. 
# initial_data <- read_rds("./data_sets/test1_forDRAM.rds")
# 
# #filter delaware dplyr filter in tidyverse package
# delaware_data <- dplyr::filter(initial_data, site == "St_Jones")
# 
# #import new data file PRESS TAB, first row is column names Header=TRUE
# #dplyr select helps select specific columns of csv
# # %>% pipe
# # the dot in bind_rows means anything before the pipe
# 
EL_RR_data <- read.csv("data_sets/All_param_sites_master.csv", header=TRUE) %>% 
 dplyr::select(1:11) 
# 
# #names(delaware_data) <- names(EL_RR_data)
# names(EL_RR_data) <- names(delaware_data)
# 
# EL_RR_De_data <- EL_RR_data %>% 
#   rbind(., delaware_data)

#bind them

#New data all sites in 1 spreadsheet
EL_RR_De_data <- read.csv("data_sets/All_param_sites_master.csv", header=TRUE) %>% 
  dplyr::select(1:11) 
summary(EL_RR_De_data)
str(EL_RR_De_data)
# days measured for each site.
#table(as.character(initial_data$site))
table(as.character(EL_RR_De_data$site))
```

There are 873, 512, and 366, measures for Eden Landing, Rush Ranch, and St. Jones.  Let's convert the site to a numerical value, which will become a critical component for running PEPRMT.

```{r echo=FALSE}
#initial_data$site <- as.numeric(initial_data$site)
EL_RR_De_data$site <- as.numeric(EL_RR_De_data$site)
```


Given that we have measures of error for Eden Landing, I must now generate more data for each column of the error data set. I'll build upon the Eden Landing data by extending it columns out. 

```{r}
# #import EL error data.
# #Michael's orig code
# #error_data <- read_csv("./data_sets/EL_ECV_ydata_18_20.csv") %>%
#  # as.data.frame(.)
# 
# EL_RR_error_data <- read.csv("data_sets/All_param_sites_master.csv", header=TRUE) %>% 
#   dplyr::select(13:15) %>%
#   as.data.frame(.)
# colnames(EL_RR_error_data) <- c("ydata", "gpf", "re")
# # resample data from ydata for RR and Stj: 512+366 = 878
# #Michael's orig code
# # moreydata <- c(sample(error_data$ydata,
# #                       size = 878,
# #                       replace = TRUE))
# # 
# # moresample <- c(sample(error_data$gpf,
# #                       size = 878,
# #                       replace = TRUE))
# #now we only need  a placeholder for Stj
# moreydata <- c(sample(EL_RR_error_data$ydata,
#                       size = 366,
#                       replace = TRUE))
# 
# moresample <- c(sample(EL_RR_error_data$gpf,
#                       size = 366,
#                       replace = TRUE))
# # for the column re, I will sample the first 512 and then first 366 values, then glue them together to generate data.
# 
# #a <- c(EL_RR_error_data[c(1:512),3])
# b <- unlist(EL_RR_error_data[c(1:366),3])
# #morere <- c(a,b)
# morere <- b
# #merge data vectors into a  df.
# site_error_data <- as.data.frame(cbind(moreydata, moresample, morere))
# 
# #colnames(site_error_data) <- c("ydata", "gpf", "re")
# #colnames(site_error_data) <- c("ydata", "gpf", "re")
# #names(EL_RR_error_data) <- names(site_error_data)
# #bring in your eden landing errors
# #el <- read_csv("./data_sets/EL_ECV_ydata_18_20.csv")
# 
# #merge above error with EL data
# #global_errors <- as.data.frame(rbind(el, site_error_data))
# colnames(site_error_data) <- c("ydata", "gpf", "re")
# global_errors <- as.data.frame(rbind(EL_RR_error_data, site_error_data))
global_errors <- read.csv("data_sets/All_param_sites_master.csv", header=TRUE) %>% 
 dplyr::select(13:15) 
#global_errors<-EL_RR_De_data[c(13:15)]

```


```{r}
#remove function
#rm(el,error_data,site_error_data,a,b,morere,moresample,moreydata)
```


## 2. Test run of the SS script

Now, that error data exists for all three sites merged into one data frame, I can calculate a sum of squares upon the data by running the `SS PEPRMT CH4` script.

```{r}
# bring in required inputs
#: global errors should be in your environment, which is the full error data set.
#error_set <- global_errors
sulfate <- 87
theta <- c(15, 0, 15, 0, 15, 0, sulfate)
#test how model performs
source('./PEPRMT_Scripts/PEPRMT_CH4_7.3_SI.R')
  

  #5. execute PEPRMT CH4
  y_model <- CH4_daily_step(theta = theta,
                           data = EL_RR_De_data,
                           wetland_type = 2)
  #make new data matrix for plotting
  EL_RR_De_data_results <- read.csv("data_sets/All_param_sites_master.csv", header=TRUE) %>% 
  dplyr::select(1:25) 
 
  EL_RR_De_data_results$CH4_mod <- y_model$pulse_emission_total
  
  #PLOT new RESULTS  2015-17
  #eden
    ggplot(data = EL_RR_De_data_results, mapping = aes(x = Day_of_year, y = CH4_mod)) 
    geom_point(alpha = 0.1, color = "blue")
    
    plot(EL_RR_De_data_results$Day_of_year[1:1217],EL_RR_De_data_results$CH4_mod[1:1217], type="b", pch=19, col="red", xlab="DOY", ylab="CH4 (gC m-2 d-1)")
# Add a line
lines(EL_RR_De_data_results$Day_of_year[1:1217], EL_RR_De_data_results$CH4_gC_m2_day[1:1217], type="l", pch=18, col="blue")#, type="b", lty=2)
# Add a legend
legend(1, 95, legend=c("mod", "obs"),
       col=c("red", "blue"))#, lty=1:2, cex=0.8)

#RR
    ggplot(data = EL_RR_De_data_results, mapping = aes(x = Day_of_year, y = CH4_mod)) 
    geom_point(alpha = 0.1, color = "blue")
    
    plot(EL_RR_De_data_results$Day_of_year[1218:2871],EL_RR_De_data_results$CH4_mod[1218:2871], type="b", pch=19, col="red", xlab="DOY", ylab="CH4 (gC m-2 d-1)")
# Add a line
lines(EL_RR_De_data_results$Day_of_year[1218:2871], EL_RR_De_data_results$CH4_gC_m2_day[1218:2871], type="l", pch=18, col="blue")#, type="b", lty=2)
# Add a legend
legend(1, 95, legend=c("mod", "obs"),
       col=c("red", "blue"))#, lty=1:2, cex=0.8)

#Stj
    ggplot(data = EL_RR_De_data_results, mapping = aes(x = Day_of_year, y = CH4_mod)) 
    geom_point(alpha = 0.1, color = "blue")
    
    plot(EL_RR_De_data_results$Day_of_year[2872:3967],EL_RR_De_data_results$CH4_mod[2872:3967], type="b", pch=19, col="red", xlab="DOY", ylab="CH4 (gC m-2 d-1)")
# Add a line
lines(EL_RR_De_data_results$Day_of_year[2872:3967], EL_RR_De_data_results$CH4_gC_m2_day[2872:3967], type="l", pch=18, col="blue")#, type="b", lty=2)
# Add a legend
legend(1, 95, legend=c("mod", "obs"),
       col=c("red", "blue"))#, lty=1:2, cex=0.8)



```




```{r}


#bring in script
source("./PEPRMT_Scripts/SS_PEPRMT_CH4_2.0.R")

# run the sum of squares script as a test
ss_global <- ss(theta = theta,
   sulfate = sulfate,
   y = global_errors,
   wetland_type = 2,
   data = EL_RR_De_data)
```


## 3. FME: modMCMC function

Here we will open the package FME and execute the 
method `modMCMC`, which will run a delayed-rejection, adaptive Monte Carlo Markov Chain, Metroplolis- Hastings Algorithm.

```{r}
# run FME
tic()
paramod <- modMCMC(f = ss,
        p = theta,
        sulfate = sulfate,
        y = global_errors,
        data = EL_RR_De_data,
        wetland_type = 2,
        jump = .01,  #1,#.5,#.05, #numeric(length=length(theta)),
        lower = c(-5, 0, -5, 0,-5, 0, 80),
          #c(-25,0,-25,0,0,0,80),
          #rep(-90, times= 7),#-90,
        upper = c(50, 60, 50, 60, 50, 60, 100),
          #c(35,30,35,30,30,30,95),
          #rep(90, times=7),#90,
        prior = NULL,
        var0 = NULL,
        wvar0 = NULL, 
        n0 = NULL,
        niter = 50000,#500000,#200000,#90 
        outputlength = 50000,
        #499000,#199000,#90
        burninlength = 1000,#10
        updatecov = 100,#100,#niter,
        covscale = 2.4^2/length(theta),
        #2.4^2/length(p),
        ntrydr = 2,
        drscale = NULL,
        verbose = TRUE)
toc()
beepr::beep(sound=2)
```

```{r}
#plot best parameter set
theta_best <- paramod$bestpar
#test how model performs
source('./PEPRMT_Scripts/PEPRMT_CH4_7.3_SI.R')
  

  #5. execute PEPRMT CH4
  y_model <- CH4_daily_step(theta = theta_best,
                           data = EL_RR_De_data,
                           wetland_type = 2)
  #add it onto results matrix
  EL_RR_De_data_results$CH4_mod_best <- y_model$pulse_emission_total
  
  #PLOT new RESULTS  2015-17
  #eden
    ggplot(data = EL_RR_De_data_results, mapping = aes(x = Day_of_year, y = CH4_mod_best)) 
    geom_point(alpha = 0.1, color = "blue")
    
    plot(EL_RR_De_data_results$Day_of_year[1:1217],EL_RR_De_data_results$CH4_mod_best[1:1217], type="b", pch=19, col="red", xlab="DOY", ylab="CH4 (gC m-2 d-1)")
# Add a line
lines(EL_RR_De_data_results$Day_of_year[1:1217], EL_RR_De_data_results$CH4_gC_m2_day[1:1217], type="l", pch=18, col="blue")#, type="b", lty=2)
# Add a legend
legend(1, 95, legend=c("mod", "obs"),
       col=c("red", "blue"))#, lty=1:2, cex=0.8)

#RR
    ggplot(data = EL_RR_De_data_results, mapping = aes(x = Day_of_year, y = CH4_mod_best)) 
    geom_point(alpha = 0.1, color = "blue")
    
    plot(EL_RR_De_data_results$Day_of_year[1218:2871],EL_RR_De_data_results$CH4_mod_best[1218:2871], type="b", pch=19, col="red", xlab="DOY", ylab="CH4 (gC m-2 d-1)")
# Add a line
lines(EL_RR_De_data_results$Day_of_year[1218:2871], EL_RR_De_data_results$CH4_gC_m2_day[1218:2871], type="l", pch=18, col="blue")#, type="b", lty=2)
# Add a legend
legend(1, 95, legend=c("mod", "obs"),
       col=c("red", "blue"))#, lty=1:2, cex=0.8)

#Stj
    ggplot(data = EL_RR_De_data_results, mapping = aes(x = Day_of_year, y = CH4_mod_best)) 
    geom_point(alpha = 0.1, color = "blue")
    
    plot(EL_RR_De_data_results$Day_of_year[2872:3967],EL_RR_De_data_results$CH4_mod_best[2872:3967], type="b", pch=19, col="red", xlab="DOY", ylab="CH4 (gC m-2 d-1)")
# Add a line
lines(EL_RR_De_data_results$Day_of_year[2872:3967], EL_RR_De_data_results$CH4_gC_m2_day[2872:3967], type="l", pch=18, col="blue")#, type="b", lty=2)
# Add a legend
legend(1, 95, legend=c("mod", "obs"),
       col=c("red", "blue"))#, lty=1:2, cex=0.8)

```




#investigate SS
```{r}
hist(paramod$SS)
plot(paramod$SS)

#bring in script
source("./PEPRMT_Scripts/SS_PEPRMT_CH4_2.0.R")

# run the sum of squares script as a test
ss_global <- ss(theta = theta_best,
   sulfate = sulfate,
   y = global_errors,
   wetland_type = 2,
   data = EL_RR_De_data)


```




## 5. Plot markov chains per parameter

here i plot each parameter and then zoom in on the last 5% of jump steps to determine the limit, or to where the posterior distribution $\pi(x)$ converges per parameter.

```{r}
df_thetas <- as.data.frame(paramod$pars)
colnames(df_thetas) <- c("t1", 
                          "t2",
                          "t3",
                          "t4",
                          "t5",
                          "t6",
                          "sulfate")

df_thetas <- df_thetas %>%
        mutate(step = c(1:nrow(df_thetas))) %>%
        pivot_longer(.,
                     c(t1,
                       t2,
                       t3,
                       t4,
                       t5,
                       t6,
                       sulfate),
                     names_to = "parameter",
                     values_to = "state")

#Plot each parameter
ggplot(data =df_thetas,
       mapping=aes(x=step,
                   y =state)) +
        geom_line(mapping=aes(col=parameter))

# Now plot up to the last 5% of the step values
lv <- as.numeric(max(df_thetas$step)-.05*max(df_thetas$step))
uv <- as.numeric(max(df_thetas$step))

ggplot(data =df_thetas,
       mapping=aes(x=step,
                   y=state)) +
        geom_line(mapping=aes(col=parameter)) +
        coord_trans(xlim=c(lv,uv))
```


