---
title: "Analysis of 2018-2020 Eden Landing data using new MEM-PEPRMT"
author: "Michael Najarro, adapted by Oikawa"
date: "11/18/2020, adapted June 2021"
output: rmarkdown::github_document
---


```{r}
library(pacman)
p_load(rCTM,
       knitr,
       tidyverse,
       magrittr,
       here,
       R.matlab,
       tictoc,
       gridExtra,
       beepr)
```


# *Phase 1: MEM*

### *Step 1: Run MEM with Cohorts*

```{r}
#import elevation data to environment.
elevation<- read.table(file="./Data_sets/EDENLAND082620.txt",sep=",")

a <- elevation %>%
  rename(record=V1,
         S1=V2,
         S2=V3,
         elevation=V4,
         edcv=V5) %>%
  slice(-25) %>%
  summarise(elev = mean(elevation)*100) %>%
  pull(.)
```



```{r}
#OLD INITIAL COHORT CODE FROM MICHAEL
# initialcohort <- c(0,#age
#         .06,#original:0,# fast_OM g
#         .06,#original: 0,#slow OM g
#         .5,# original 0 #respired OM g
#         400,#250,#450,#original: 222.16,#mineral
#         0, # original: 0#root mass
#         1.5, # original: 0#layer top
#         6,#from carlin poster#layer bottom
#         65,#original 70.. cumsum(layer_bottom-layer_top) cum cohort volume cm3
#         2010)#year
# 
# 
# initialcohort <- as.data.frame(rbind(initialcohort))
# colnames(initialcohort) <- c("age",
#                           "fast_OM",
#                           "slow_OM",
#                           "respired_OM",
#                           "mineral",
#                           "root_mass",
#                           "layer_top",
#                           "layer_bottom",
#                           "cumCohortVol",
#                           "year")

#NEW INITIAL COHORT TABLE FROM JIM JULY 2021
rootDepthMax = 30
omPackingDensity = 0.085
mineralPackingDensity = 1.99
rootPackingDensity = omPackingDensity

moonscapeCohorts <- data.frame(age=rep(0, round(rootDepthMax+0.6)), # set all ages to 0
                      fast_OM=rep(0, round(rootDepthMax+0.6)), # Note that fast, slow, and root mass initial conditions are all set to 0
                      slow_OM=rep(0, round(rootDepthMax+0.6)),
                      respired_OM=rep(0, round(rootDepthMax+0.6)),
                      mineral=rep(mineralPackingDensity,round(rootDepthMax+0.6)), # Mineral mass is 100% so equal to the packing density
                      root_mass=rep(0,round(rootDepthMax+0.6)),
                      layer_top=0:((round(rootDepthMax+0.6)-1)), # 1 cm depth increments
                      layer_bottom=1:round(rootDepthMax+0.6)) %>% 
  dplyr::mutate(cumCohortVol = cumsum(layer_bottom-layer_top))
```


```{r}
startYear=2010

#PATTY'S SET UP
# memCohortExample2 <- rCTM::runCohortMem(startYear=2010,
#                  endYear=startYear+99,
#                  coreyear=2020,
#                  relSeaLevelRiseIni=0.24,#rslr at time 1 (cm yr-1) 0.24
#                  relSeaLevelRiseTotal=100,#total rSLR over 100yrs (cm) Schile ref
#                  initElv=165.0979,#initial elevation of wetland (cm NAVD88)                                 
#                  meanSeaLevel = 110,# tidal datums (cm NAVD88)
#                  meanSeaLevelDatum=98.1,#0,from alameda creek
#                  meanHighWaterDatum=194.7,#original194.7 or 175.2- from alameda creek
#                  meanHighHighWaterDatum = 213.7,#NA,from alameda creek
#                  meanHighHighWaterSpringDatum = NA,
#                  suspendedSediment=.000045,#  grams cm-3 or 45 mg/L
#                  lunarNodalAmp=2.5,#cm Ariane used 3.46
#                  bMax=0.09,#original.90,3 max biomass g cm-2
#                  zVegMin=80,#elevation of min biomass cm NAVD88
#                  zVegMax=350, #elevation of max biomass cm NAVD88
#                  zVegPeak=170,#180,#elevation of peak biomass cm NAVD88
#                  plantElevationType="orthometric",
#                  rootToShoot=2,#g/g
#                  rootTurnover=0.5,#1,#yr-1
#                  abovegroundTurnover = NA,
#                  speciesCode = NA,
#                  rootDepthMax=30,#cm
#                  shape = "linear",
#                  omDecayRate=0.2,#L/yr-should be in g/yr
#                  recalcitrantFrac=0.35,#g/g
#                  captureRate=1,
#                  settlingVelocity=0.275,
#                  omPackingDensity = 0.085,#default
#                  mineralPackingDensity = 1.99,#default
#                  rootPackingDensity = omPackingDensity,
#                 initialCohorts = NA,
#                  uplandCohorts = NA, 
#                  supertidalCohorts = NA,
#                  supertidalSedimentInput = NA) 
#JIM's SET UP JULY 2021
memCohortExample2 <- rCTM::runCohortMem(startYear = 2010,
                                     relSeaLevelRiseInit = 0.24, 
                                     relSeaLevelRiseTotal = 40, 
                                     initElv = 165, 
                                     meanSeaLevel = 110, 
                                     meanSeaLevelDatum = 98.1, 
                                     meanHighWaterDatum = 194.7, 
                                     meanHighHighWaterDatum = 213.3, 
                                     meanHighHighWaterSpringDatum = NA, 
                                     suspendedSediment = .000045, 
                                     lunarNodalAmp = 2.5, 
                                     lunarNodalPhase = 2011.181, 
                                     nFloods = 705.79, 
                                     bMax = 0.09, 
                                     zVegMin = 80, 
                                     zVegMax = 350, 
                                     zVegPeak = NA, 
                                     plantElevationType = "orthometric",
                                     rootToShoot = 2, 
                                     rootTurnover = 0.5, 
                                     abovegroundTurnover = NA, 
                                     speciesCode = NA, 
                                     rootDepthMax = 30, 
                                     shape = "linear", 
                                     omDecayRate = 0.2, 
                                     recalcitrantFrac = 0.35, 
                                     captureRate = 0.275, 
                                     omPackingDensity = 0.085, 
                                     mineralPackingDensity = 1.99, 
                                     initialCohorts = moonscapeCohorts, 
                                     uplandCohorts = NA, 
                                     supertidalCohorts = NA, 
                                     supertidalSedimentInput = NA
                                     )

slow <- tapply(memCohortExample2$cohorts$slow_OM,
           memCohortExample2$cohorts$year,
           FUN = mean)
slow
fast <- tapply(memCohortExample2$cohorts$fast_OM,
           memCohortExample2$cohorts$year,
           FUN = mean)
fast
resp <-tapply(memCohortExample2$cohorts$respired_OM,
           memCohortExample2$cohorts$year,
           FUN = mean)
resp
```


## **Step 2: obtain the sum of slow and fast organic matter pools**

At this point I entirely skip the calculation and downscaling of NPP.

Instead I calculate two important values from MEM to input into the respiration component of PEPRMT. These values will directly correspond to the slow and fast organic matter components of each soil cohort from MEM. The sum of these values approximate the carbon stored within the labile and SOC pools described in the PEPRMT model.


The MEM ouputs for carbon -The slow and fast organic measures - will become inputs for the ecosystem respiration component of PEPRMT. Specifically, they will equate to the sum of slow and fast organic matter that is within one meter below the soil surface at and up to the time of interest (includes all years prior, up to, and include year of interest) in accordinance with the PEPRMT model (see Oikawa 2017) to simulate soil sampling of core data. 

Note thatin previous iterations of MEM-PEPRMT in Rush Ranch, we did not consider the 1 meter depth because the total height of the soil cohorts from MEM were within 1 meter.

The relationship between these pools can be described as follows:

```{r}
y<- tribble(
  ~MEM_Variable, ~Equiv._PEPRMNT_C_Pool, ~PEPRMNT_Variable, ~theta_element,
  "Slow_OM", "Soil Organic Carbon (SOC) Pool", "S2", "theta[5]",
  "Fast_OM", "Labile Carbon Pool", "S1", "theta[6]"
)

kable(y)
```
## **Step 2: check if biomass pools are reasonable**

select out years of interest based on the data we have
grab above and belowground biomass for those years-these need to look reasonable given the site
estimate an annual NPP-should also look reasonable

```{r}
yrs <- c(2016)
yrs <- c(2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021,2022,2023, 2024, 2025, 2026)
#2.c) now extact out the above and below ground biomasses/.
# MEM's units for biomasses is: g OM/year. 
annual_agb <- as.data.frame(
  memCohortExample2$annualTimeSteps) %>%
  filter(between(year, min(yrs)-1, max(yrs)) ) %>%
  select(aboveground_biomass) %>%
  pull(.)

annual_bgb <- as.data.frame(
  memCohortExample2$annualTimeSteps) %>%
  filter(between(year, min(yrs)-1, max(yrs)) ) %>%
  select(belowground_biomass) %>%
  pull(.)

#2.d) create your annual difference NPP.
# latest units used:
# (g OM/cm^2*year) * 100^2 cm^2/M^2 = g OM/m^2*year
#multiply OM by 0.5 to get gCm-2 y-1
an_NPP <- (annual_agb + annual_bgb)*10000*0.5
an_diff_NPP <- numeric(length(an_NPP))

for(y in 2:length(an_NPP)){
  an_diff_NPP[y] <- an_NPP[y] - an_NPP[y-1]
  }
```

Now we sum up cohorts from the table and check if reasonable and use decomposed OM to run Reco PEPRMT model

Here I calculate the depth of the soil accreted for 2018 and filter out the 2018 data from MEM outputs. I also check if the soil is within one meter of the surface.

```{r}
# first identify the values of slow and fast om
# that are: 
#   1. within a meter
#   2. within a time interval of the earliest
#       year up to, and including the year of 
#       interest.

#note:
# Within a given year, all rows before the newest
# incremented "age" (n+1th row) are considered past cohorts,
# so only sum the rows within a year of interest!

#2.a) create table cohort up to year 2017.
cohort <- as.data.frame(memCohortExample2$cohorts)
#cores <-- as.data.frame(memCohortExample2$core)

#2.b) create a column that calculates the height
#       of each layer.
lb <- as.vector(cohort$layer_bottom)
lt <- as.vector(cohort$layer_top)

#2.c) extract out cohort data for 2018.
cohort18 <- cohort %>%
  mutate(depth = lb-lt) %>%
   filter(year == 2018)

cohort19 <- cohort %>%
  mutate(depth = lb-lt) %>%
   filter(year == 2019)

cohort20 <- cohort %>%
  mutate(depth = lb-lt) %>%
   filter(year == 2020)

#2.d) how many layers are exactly one meter
# below the last year of interest (2020) in the depth column?
cohort20 %>%
  summarise(total_depth = sum(depth))


# look at size of respired, fast and slow OM in year 2016; units: gOM/cm3 * 0.5 gC/gOM *1e6 cm3/m3 = g C m-3
percentOM <- 0.5
  cum_vol_cohorts_18<- last(cohort18$cumCohortVol)#Units: cm-3
  cum_respired_OM_18 <- ((sum(cohort18$respired_OM)*percentOM)/cum_vol_cohorts_18)*1e6#g C m-3
  theta5_18=cum_respired_OM_18
  #theta5 <-7200 #reasonable value for EL
  fast_OM_18 <- ((sum(cohort18$fast_OM)*percentOM)/cum_vol_cohorts_18)*1e6#g C m3
  slow_OM_18<- ((sum(cohort18$slow_OM)*percentOM)/cum_vol_cohorts_18)*1e6#g C m3
 
  cum_vol_cohorts_19<- last(cohort19$cumCohortVol)#should be in cm-3
  cum_respired_OM_19 <- ((sum(cohort19$respired_OM)*percentOM)/cum_vol_cohorts_19)*1e6#g C m3
  theta5_19=cum_respired_OM_19
  #theta5 <-7200 #reasonable value for EL
  fast_OM_19 <- ((sum(cohort19$fast_OM)*percentOM)/cum_vol_cohorts_19)*1e6#g C m3
  slow_OM_19<- ((sum(cohort19$slow_OM)*percentOM)/cum_vol_cohorts_19)*1e6#g C m3
  
  
  cum_vol_cohorts_20<- last(cohort20$cumCohortVol)#should be in cm-3
  cum_respired_OM_20 <- ((sum(cohort20$respired_OM)*percentOM)/cum_vol_cohorts_20)*1e6#g C m3
  theta5_20=cum_respired_OM_20
  #theta5 <-7200 #reasonable value for EL
  fast_OM_20 <- ((sum(cohort20$fast_OM)*percentOM)/cum_vol_cohorts_20)*1e6#g C m3
  slow_OM_20<- ((sum(cohort20$slow_OM)*percentOM)/cum_vol_cohorts_20)*1e6#g C m3
```


```{r}
rm(a,
   elevation,
   lb,
   lt,
   fastomPackingDensity,
   omPackingDensity,
   resp,
   fast,
   slow,
   cohort18,
   cohort19,
   cohort20,
   memCohortExample2)
```



# *Phase 2: PEPRMT*

## *Ecosystem Respiration*

### **Step 1: import your data to environment.**



```{r message=FALSE}
data <- read_csv(file="./Data_sets/EL_2018_2020_master_9_30_20_EVI_uncertainty.csv") %>%
  mutate(GI = rep(0, nrow(.)),
         Season = rep(0, nrow(.))) %>%
         #wc90_filler = rep(0, nrow(data))
  select(Day_of_year,
         Discont_day_of_year,
         Air_temp_daily_ave_degree_C,
         Water_table_daily_ave_cm,
         PAR_daily_ave_umol_m2_day,
         Reco_gC_m2_day,#dummy
         GPP_gC_m2_day,
         EVI,
         Season,
         Year,#sub in uncertainty when you get it
         Wetland_age_years,
         FPAR) %>%
 filter(between(Year, 2018, 2021)) %>%
  as.data.frame(.)
```
Apply Light Use Efficiency Model
Driven by EVI
will insert here Gwen's model output from Google Earth Engine
as a placeholder for now, I will used obs GPP to run the Reco model
```{r}
#Insert here import of Gwen's GPP from GEE
#Insert here import of Gwen's GPP from GEE

#Run a loop for each year in a vector of years where you:
#   - extract year data
#   - store in df
#   - run mem-pep Reco on that data
#   - store df as element of list
  
#3.a) pull your reco function in and setup storage space
#source('./Peprmt_files/PEPRMT_final_sys_CO2_Reco_V2.R')
source('./Peprmt_files/PEPRMT_final_sys_CO2_GPP.R')
#year_vector <- c(2016,2017)
#outcome_lst <- list(rep(NA, length(year_vector)))
#daysofyear <- list(c(1, 271), c(272,512))
#wetland_type <- "coastal"
     
#3.b) run the loop
  #for(i in 1:length(year_vector)) {
   # cohort_i <- cohort %>%
    #  filter(year == year_vector[i]) %>%
    #  mutate(depth = layer_bottom - layer_top)
    
   LUE<-0.65
     # run peprmt Reco
    theta <- c(4, 4, 0, 0, 0,LUE)
    GPP_mod_EL <- PEPRMT_final_sys_CO2_GPP(theta,
                                           data)
    
    #plot(data$daily_DOY_cont,GPP_mod_RR)
    #par(new = TRUE)
    #plot(data$daily_DOY_cont, data$daily_gpp_obs, axes = FALSE, xlab = "", ylab = "")
  #PLOT RESULTS  
    plot(data$Day_of_year,GPP_mod_EL, type="b", pch=19, col="red", xlab="DOY", ylab="GPP")
# Add a line
lines(data$Day_of_year, data$GPP_gC_m2_day, pch=18, col="blue", type="b", lty=2)
# Add a legend
legend(100, 0, legend=c("mod", "obs"),
       #lty = c(1,2),
       col=c("red", "blue"))#, lty=1:2, cex=0.8)

?legend  
  
    #Now save over the GPP with the mod GPP to get ready to run the Reco mod
      data$daily_gpp_mod <- GPP_mod_EL
       #export as csv file
    write.csv(data,'EL_data_GPP_mod.csv') 
```


### **Step 2: Prepare the data for peprmt Reco script**

In this step, I substitute the tower observed measures of GPP for a vector of zeroes.

Within the PEPRMT Reco function, GPP measures are susbstituted directly fora variable called "C2in", which is then used to calculate the S2 pool of carbon in PEPRMT. By converting the GPP time step measures to zero, the S2 carbon pool depends strictly on the Labiale Carbon Pool, which is the sum of the fast and respired organic matter pools calculated from MEM.
```{r message=FALSE}
data <- read_csv(file="./Data_sets/EL_2018_2020_master_9_30_20_EVI_uncertainty.csv") %>%
  mutate(GI = rep(0, nrow(.)),
         Season = rep(0, nrow(.))) %>%
         #wc90_filler = rep(0, nrow(data))
  select(Day_of_year,
         Discont_day_of_year,
         Air_temp_daily_ave_degree_C,
         Water_table_daily_ave_cm,
         #PAR_daily_ave_umol_m2_day,
         #FPAR,
         GPP_gC_m2_day,
         GI,
         Season,
         #wc90_filler,
         Wetland_age_years,
         Year) %>%
 filter(between(Year, 2018, 2021)) %>%
  as.data.frame(.)

# 2.a) substitute the peprmt GPP data with
#       MEM-calculated NPP data; relabel column.
#data[5] <-  c(rep(0, nrow(data)))
data[5] <- GPP_mod_EL
```


### **Step 3: Execute peprmt Reco using sum of fast and slow OM of MEM for 2018**

```{r}
#Run a loop for each year in a vector of years where you:
#   - extract year data
#   - store in df
#   - run mem-pep Reco on that data
#   - store df as element of list


#3.a) pull your reco function in and setup storage space
source('./Peprmt_files/PEPRMT_final_sys_CO2_Reco_reduced.R')
year_vector <- c(2018,2019,2020,2021)
outcome_lst <- list(rep(NA, length(year_vector)))
daysofyear <- list(c(47, 365), c(366,730), c(731,1096),c(1097,1263))
wetland_type <- "coastal"
     
#3.b) run the loop
  for(i in 1:length(year_vector)) {
    cohort_i <- cohort %>%
      filter(year == year_vector[i]) %>%
      mutate(depth = layer_bottom - layer_top)
    
    # set up your theta values. note that multiply by 10^6 to
    #convert from gC/cm^3 to gC/m^2, when we consider one meter
    #of soil across all years of interest.
    theta5 <- (mean(cohort_i$slow_OM*.5)/mean(cohort_i$depth*.5))*1000000
    #theta6 <- ((mean(cohort_i$fast_OM*0.5)+mean(cohort_i$respired_OM*0.5))/mean(cohort_i$depth*0.5))*1000000
    
    #Patty's new version for theta6-sum up the respired OM for the given year
    theta6 <- sum(cohort_i$respired_OM)*1000000
     # run peprmt Reco
    theta <- c(1.5, 0, 1.5, 0, theta5, theta6)
    ER_mod_RR <- PEPRMT_final_sys_CO2_Reco(data,
                                           theta,                                           wetland_type)
    
    # merge peprmt output + obs data
    co2_i <- ER_mod_RR %>%
      as.data.frame(.) %>%
      mutate(DOY = c(data$Discont_day_of_year),
             DOY_cont = c(data$Day_of_year)) %>%
      select(Reco_full,
             DOY, 
             DOY_cont,#,
             S1,
             S2
             ) %>%
      rename(CO2_flux=Reco_full) %>%
      mutate(data_type = c(rep(paste0("mem_pep_",year_vector[i],sep=""),
                               nrow(.)))) 
    
    #filter the data between min & max values of obs data
    #for given year
    s <- unlist(daysofyear[i])
    co2_i <- co2_i %>%
      slice(s[1]:s[2])
    
    #store your dataframe iteration of Reco into the list
    outcome_lst[[i]] <- co2_i
  }

 #export as csv file
    write.csv(ER_mod_RR,'EL_data_Reco_mod.csv') 
```


### **Step 4: Munge the data from loop**

```{r message=FALSE}
#4.a) row bind the elements of loop outcomes together.
bigc02 <- do.call('rbind', outcome_lst)

#4.b) save your S1 and S2s into a separate df, then toss.
s1 <- bigc02$S1
s2 <- bigc02$S2

carbon_pools <- as.data.frame(cbind(s1, s2))
colnames(carbon_pools) <- c("S1", "S2")

#4.c) remove S1 and S2 from bigc02.
bigc02 <-bigc02 %>%
  select(-S1,-S2)

#4.d) Bring in the observed Reco data  
data2 <- read_csv(file="./Data_sets/EL_2018_2020_master_9_30_20.csv") %>%
  filter(between(Year, 2018, 2021)) %>%
  select(Reco_gC_m2_day,
         Discont_day_of_year,
         Day_of_year) %>%
  mutate(data_type = c(rep("obs_data", nrow(.)))) %>%
  rename(CO2_flux = Reco_gC_m2_day,
         DOY = Discont_day_of_year,
         DOY_cont= Day_of_year) %>%
  as.data.frame(.)


#4.c) bind loop data with observed data
bigc02 <- bigc02 %>%
  as.data.frame(.) %>%
  #slice(-(272:783)) %>%
  bind_rows(.,data2) %>%
  pivot_wider(names_from = data_type,
              values_from = CO2_flux) %>%
  pivot_longer(c(mem_pep_2018,
                 mem_pep_2019,
                 mem_pep_2020,
                 mem_pep_2021,
                 obs_data),
               names_to = "data_source",
               values_to = "Respiration")
```


### **Step 5: Plot your Reco values**

```{r}
#5.a). return a plot of the model ouputs & obs. flux data
ggplot(data=bigc02,
       mapping = aes(x = DOY_cont,
                     y = Respiration,
                     color = data_source)) +
  geom_line(na.rm=TRUE) +
  labs(x = "Day of year",
       y = expression(paste("Respiration",
                             " ","(grams C"," ",
                             m^{-2},day^{-1},")",)),
       color = "Respiration Source",
       title = "MEM-PEPRMT: Respiration 2018-2021",
       subtitle = "data obtained from Eden Landing") +
  scale_y_continuous(expand=c(0,0)) +
  scale_color_manual(labels = c("Modeled 2018",
                                "Modeled 2019",
                                "Modeled 2020",
                                "Modeled 2021",
                                "Obs"),
                     values=c("red",
                              "blue",
                              "green4",
                              "black")) +
  theme(panel.grid = element_blank(),
        panel.background = element_rect(fill = "white")
        )
```


## *Methane flux*

```{r}
#clear the environment
rm(i,
   s,
   startYear,
   theta,
   theta6,
   theta5,
   wetland_type,
   year_vector,
   PEPRMT_final_sys_CO2_Reco,
   co2_i,
   cohort_i,
   #data2,
   daysofyear,
   s1,
   s2,
   bigc02,
   #data,
   data2
   )
```


### **Step 1: Merge the observed data with the outputs of the 2018-2020 respiration component of PEPRMT**

In order to run the methane component of PEPRMT, the model requires measures of carbon within the labiale and SOC pools, which are identified as columns S1 and S2 of the respiration output.


```{r message=FALSE}
#1.a): bring back your observed data for 2018-2020 with gpps.
# make sure the columns match
data <- read_csv(file="./Data_sets/EL_2018_2020_master_9_30_20.csv")
dt <- read_csv(file="./Data_sets/EL_2018_2020_master_9_30_20.csv") %>%
  mutate(GI = rep(0, nrow(.)),
         Season = rep(0, nrow(.)), 
         wc90_filler = rep(0, nrow(data)) ) %>%
  select(Day_of_year,
         Discont_day_of_year,
         Air_temp_daily_ave_degree_C,
         Water_table_daily_ave_cm,
         PAR_daily_ave_umol_m2_day,
         FPAR,
         GPP_gC_m2_day,
         GI,
         Season,
         wc90_filler,
         Wetland_age_years,
         Year) %>%
 filter(between(Year, 2018, 2020)) %>%
  as.data.frame(.)


#1.b): merge your Reco ouputs with carbon pools and the
#       filtered 2018 data outputed from MEM.
a<-cbind(dt, carbon_pools)
rm(dt)
```


### **Step 2: Load the salinity inputs into the environment**

I will be using a revised version of the peprmt methane component that incorporates salinity measures. The model requires three additional inputs: Sal_int, Sal_slope, and salinity measures.

Note that there is no need for unit conversions applied to the S1 and S2 carbon pools. In the previous conversion in Reco, the pools converted from g C/cm^3 to g C/m^2 when considered with respect to one meter depth. there should be no unit changes between the phases of PEPRMT.

Note: Previously I had been applying a unit conversion to the S1 and S2 pools. I wasn't totally sure why;  I was trying to get the values to approximate a percentage and because without a conversion totally kills the PEPRMT Ch4. The reasons the model crashes is because currently I am applying a random sample of S1 and S2 values around the gamma distribution that is centered around the mean..??

```{r}
#2.a)  generate a salinity vector 
salinity <- c(data$Salinity_daily_ave_ppt)

#2.b) generate the inputa data frame to feed into PEPRMT CH4.
a <- a %>%
  mutate(Sal = salinity) %>%
  select(Day_of_year:Wetland_age_years, Year, Sal, S1, S2)
```


### **Step 3: setup other inputs to Ch4 script**

```{r}
# 3.a) create your model inputs
#theta= c(-13, 4, -13, 4, 13, 4)
theta= c(-20, 4, -20, 4, 14, 4, 88) #original for Stj

#3.b)back transform Sarah's intercepts
# commented numbers come from Sarah's email.
#equation 2 relates to the plateau of the segment regression:
#Slope2 = -0.04345077
#Intercept2 = -2.509939
Sal_Slope2 = -0.04345077
Beta_knot2 = -2.509939 + abs((12.9*Sal_Slope2))
Sal_int2 = exp(Beta_knot2) + exp(12.9*Sal_Slope2)

# equation 1 relates to the back, steeper portion of the segment
# regression, where >12.9 ppt
#Slope1 = -0.1773802
#Intercept1 = -1.139622..THIS NUMBER CANNOT BE TRUE!
# SEE POSTER IMAGE OF SALINITY GRAPH...
# USE AN APPROXIMATION FROM THE GRAPH
#INTERCEPT 1 = -0.6
Sal_Slope1 = -0.1773802
Beta_knot1 = -0.6 + abs((12.9*Sal_Slope1))
Sal_int1 = exp(Beta_knot1) + exp(12.9*Sal_Slope1)


#second attempt with back-transformed numbers below
#Sal_Slope2 <- -0.05 
#Sal_int2 <- 0.73585193

#Sal_Slope1 <- -0.2 
#Sal_int1 <- 8.92208026

#first attempt with numbers below: raw inputs.
#Sal_Slope1 <- -0.05 
#Sal_Slope2 <- -0.2 
#Sal_int1 <- -0.2
#Sal_int2 <- -2.2
```



### **Step 4: Implement the latest version of the methane component of MEM-PEP one time**

Please the see the notes within the file PEPRMT_final_sys_gammaCH4_V6.R for details on model modifications; this is the latest version of the methane component of PEPRMT.

```{r}
#4.a) load the new methane flux script
source('./Peprmt_files/PEPRMT_Final_sys_CH4_V6.R')
```


```{r}
#4.b) execute your model given the inputs
tic()
CH4_mod_RR <- CH4_daily_step(theta,
                             a,
                             Sal_int1,
                             Sal_int2,
                             Sal_Slope1,
                             Sal_Slope2,
                             #Sal_slope,
                             #Sal_int,
                             x = 1,
                             wetland_type = 2)
toc()
beep(1)
```


do a quick plot of the ch4 outputs below

```{r}
test_graph <- CH4_mod_RR
x <- data$CH4_gC_m2_day
#x<- RR_1617_master$daily.wm.gf.obs

test_graph %>%
    mutate(observed = x,
           sum_of_ms = M1 + M2,
           roxi =r_oxi,
           ch4water = ch4_water) %>%
  pivot_longer(c(avg_Pulse_Emission_Total,
                 M1,
                 M2,
                 hydro_flux,
                 Plant_flux,
                 observed,
                 sum_of_ms,
                 roxi,
                 ch4water),
               names_to='outputs',
               values_to='measures'
               ) %>%
  ggplot(data=., mapping = aes(x=index,
                               y=measures,
                               color= outputs)) +
  geom_line()
```


### **Step 5: Munge your data for graphing**

```{r}
#5.a) clear environ
rm(carbon_pools,
   salinity,
   p,
   Sal_int,
   Sal_slope,
   salt,
   theta,
   year_vector,
   CH4_daily_step,
   daysofyear)
```


```{r message=FALSE}
#5.b) merge your data sets:
#x: matlab observed ch4
#a: matlab data used to extract day counters
#Ch4_mod_RR: peprmt ch4 model output
data_CH4_mod_EL <- cbind(a,
                         CH4_mod_RR,
                         x) %>%
  select(Day_of_year,
         S1,
         S2,
         avg_Pulse_Emission_Total,
         x) %>%
  rename(obs_ch4_matlab = x)
```


Do side step where you calculate your rmse, r squared and cumulative sums of obseved and predicted methane.

```{r}
#5.c 
#cumulative sums
print(paste("final cumulative sum value of modeled methane is",round(cumsum(data_CH4_mod_EL$avg_Pulse_Emission_Total)[873], digits = 6)))

print(paste("final cumulative sum value of observed methane is", round(cumsum(data_CH4_mod_EL$obs_ch4_matlab)[873], digits=6) ))

#rmse
o <- data_CH4_mod_EL$obs_ch4_matlab
m <- data_CH4_mod_EL$avg_Pulse_Emission_Total

print(paste("RMSE between modeled and observed methane is",round(sqrt(mean(m - o)^2), digits = 6) ))


#r squared via basic linear model
plot(m~o, col = c("red","blue"))

#r squared
mymodel <- lm(avg_Pulse_Emission_Total~obs_ch4_matlab,data = data_CH4_mod_EL)

summary(mymodel)

plot(mymodel)

```


```{r}
#5.d) one final munge to stack your measures and observed
# measures together.
  data_CH4_mod_EL <- data_CH4_mod_EL %>%
  #  mutate(avg_Pulse_Emission_Total = avg_Pulse_Emission_Total)%>% 
    pivot_longer(c(obs_ch4_matlab,
                   avg_Pulse_Emission_Total#,
                   #obs_ch4_recent
                   ),
                 names_to ="methane_flux",
                 values_to = "CH4_measure")
```  


### **Step 6: Plot model outputs alongside obsreved data**

```{r}  
  #6.a) plot
  CH4_EL<- ggplot(data = data_CH4_mod_EL) +
     geom_line(aes(x= Day_of_year,
                   y= CH4_measure,
                   color=methane_flux)) +
     labs(x = "Day of year",
          y = expression(paste("CH4 exchange"," ","(grams C"," ", m^{-2},day^{-1},")")),
          color = expression(paste("Pulse"," ","Emission")),
          title = "MEM-PEPRMT: Methane Emissions 2018-2020",
          subtitle = "data obtained from Eden Landing") +
     scale_y_continuous(expand=c(0,0)) +
     scale_color_manual(labels =c("Modeled",
                                  "Obs"),
                        values=c("blue",
                                 "grey")) +
     theme(
       panel.grid = element_blank(),
       panel.background = element_rect(fill = "white")
     )
ggsave(CH4_EL,file = "CH4_EL_MEM.jpeg", width=5, height = 3, units = "in")
```

```{r}
rmse<-sqrt((((CH4_mod_RR$avg_Pulse_Emission_Total-data$CH4_gC_m2_day)^2)/366))
sum(rmse, NA, na.rm=TRUE)
plot(CH4_mod_RR$pulse_emission_total)
```
### save certain data for graphing for poster presentations
```{r}
save(CH4_mod_RR,
     a,
     data,
     file="/home/worker/Documents/AGU_poster_graphs/revised_EL_data.RData")
```

